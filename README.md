# php
learn php


basics 目录为学习php基础知识
# 1
    # 变量的理解
        变量与值的对应关系----引用关系，即是指使用该变量名所指的变量名

    # 传至的方式
        值传递： 将变量的值进行拷贝，然后把拷贝的新值赋值给另一个变量。
        引用传递： 将变量的引用关系进行拷贝，  然后用此关系数据跟另一个变量建立关系。
        在php中默认变量之间传值是，都是使用值传递。
            如果想要实现引用传递，必须使用使用引用传递符号"&"
    # 可变变量    
        $abc= 'vl';$vl=123;
        $$abc ->$($bac)-> $vl->123
    # 预定义变量： （超全局数组）
        都是数组，都具有超全局作用域，都是系统自动维护
        $_GET : 通过get方式发送/提交的数据集合
        $_POST: 通过post方式发送/提交的数据集合
        $_REQUEST: 通过get 和 post方式发送/提交的数据集合
        $_SERVER:  
            储存了服务器和客户端的相关信息
            SERVER_NAME

        $_GLOBALS:
    # 常量
        定义形式：
            使用函数定义： define(常量名，常量值)   
            使用const 关键字 const 常量名= 常量值;
             注： 常量只能是标量类型（string, floot ,bool）
        使用常量
            直接使用常量名
            使用函数： constant('常量名')，这方法更具有灵活性
                const C1 = 1;
                const C2 = 2;
                for($i=1;$i<=2;$i++){
                    echo constant("C".$i); //灵活的使用常量
                }
            常量变量的区别
                定义形式，使用形式不同，作用域范围：常量是超全局的 ，可用类型不同
            判断常量是否存在：
                一个函数： defined('常量名') 
            定义一个未定义的常量
                php会报一个notice 错误，并又认可该常量，其值就是常量名字本身  
            预定义常量
               很多很多： M_PI() 、PHP_OS、 E_ERROE...
            魔术常量
                很少的几个：__DIR__、__FILE__、__LINE__、
# 2
    # 数据类型
        整数类型  
            形式 ： $v1= 123; $v2= 0123; //八进制 $v3= 0x123; //16进制
            应用函数有： decbin()、decoct()、decbex()
        浮点数类型 
            形式：  $v1 = 10.12带小数点  ；$v2= 123E4含科学计数法E的; $v3= 123e4e5//这是不对的
            注意：  在二进制层上 浮点数的小数部分不能准确表示数据。 与js一样，尽量不要比较大小。

        字符串类型
            单引号字符串
                可识别转移符：
                    说明： 实际上，只有字符串中的最后一个“\”才必须使用转移符
                    例： $v1 = 'abc\sdds'; //有效
                         $v2 = 'asd\\sfd'; //也有效
                         $v3 = 'abcdef\\' // 此时必须写
            双引号字符串
               可识别转移符： \\ \" \s  \g \t 
               可以识别双引号字符串的变量（以$为表示）
            如果一个字符串没有识别的转移符和没有识别的变量，推荐使用单引号

        布尔类型
            能被转换为false的值有： "" 、0 、0.0、 "0"、 null 、[] 、未定义
            其他的当做true;
            
        类型转换
            PHP作为弱类型语言，类型的自动转换是常态
            类型的强制转换，反而没有那么多、
            自动转换：通常根据运算符的需要发生的 
            强制转换： （目标类型）数据；

        算数运算符 + - * / % ++ --

        比较运算符： > >= < <=  == != ===  !== 
            规则：
                1 常规： 对数字进行比较
                2 如果不是数字: 而包含布尔值，则转换为布尔值运算
                3 否则，包含数字，则转换成数字比较
                4 否则，但是都是纯数字字符串，也比当做数字比较

        逻辑运算符
            && || ！
    # 位运算
        基本位运算规则：
            按位与： 1&1==>1,1&0==>0,0&1==>0,0&0==>0
            按位或： 1|1==>1,1|0==>1,0|1==>1,0|0==>0
            按位非： ~1==>0, ~0==>1;
            按位异或： 1^1==>0 1^0==>1  0^1==>1  0^0==>1  (相同结果就是0 不同就是1) 
        对常规整数的按位运算
            按位与：
            按位或： 
            按位非：
            按位异或：   
                $v1=9;    00001001
                $v2=19;   00010011
                          00011010(相同结果就是0 不同就是1)    
                          这就是2的四次+ 2的三次+ 2的二次= 16+8+2 = 26；
    # 原码
        就是将一个数字通过数学方法转换成二进制的形式
        并规定：    
            第一个位为符号位，0表示整数 1表示负数
        但是：
            在cup内部，计算都是以补码的形式进行的   

    # 反码
        正数的反码： 其本身
        负数的反码： 符号位不变，其余每一位取反

    # 补码
        正数的补码： 其本身
        负数的补码： 符号位不变，反码加1

    # 管理一组事物的开关状态
        有多个数据，其都有两个状态，并且可以将他们确定位置（顺序）
        那么，我们就可以用一个数字（整数）就可以实现看多个数据的“统一管理”
        首先，设定多个基础数据，通常是常量
            D1 =1;D2=2;D3=4;D4=8;......
        则：变量$state =17; //一个随便的数字，就可以代表着多个数据的任意可能组合
        常见的需求有：
            1 确定某个数据的当前值（状态）： if($state & Dn>0){为真}else{为假} //n代表任意某个数据
            2 设定某个数据为真： $state = $sate | Dn; //n为1,2,3.....
            3 设定某个数据为假： $state = $state & ~Dn;  //n为1,2,3.....

    # 循环
        3要素
            循环变量初始化
            循环变量的条件判断 
            循环变量值的改变
        2中断
            break；
            continue  ;        
# 3
    # 文件加载
        4个语句：
            include()
            require()
            include_once()
            require_once()          
        文件路径
            1 相对路径 ./
            2 绝对路径    
                本地绝对： C:/d1/d2  Linux /d1/d2
                网络绝对： http://www.abc.com/d1/d2
            3 只有文件名 
                他会在以下三个步骤中找到指定文件
                    A 在系统设置的include——path所设定的路径中去找
                    B 如果没找到，则到当前网页文件所在的路径（当前工作目录）中找 
                    C 如果没有找到，则到当前载入语句所在文件的所在目录中找

        文件载入执行过程
            1 退出php模式，进入 HTML模式
            2 将加载的文件代码插入此位置，并执行；
            3 在退出HTML模式，重新进入PHP模式，继续后续代码执行
        几个区别：
            include 和 require 前者没有找到文件，报错后继续执行后续代码，后者则停止运行
            include 和 include_once,require和 require_once 前者不检查是否重复加载，后者检查，并保证不会重复加载。
        return 关键字
            作用类似于函数中的return语句，有两个作用：
                1 结束载入语句
                2 并可以返回数据值
    # 错误处理
        错误分类： 语法错误，运行时错误，逻辑错误                
        常用错误分级：
            系统错误： E_ERROR,E_WARING, E_PARSE,E_NOTICE
            用户自定义错误: E_USER_ERROR, E_USER_WARING, E_USER_NOTICE
            其他:E_ALL, E_STRICT
        错误触发：
            正常触发： 程序执行过程中体现
            人为触发： 
                trigger_error('错误描述'，用户错误代号)    
         错误的显示控制：
            display_error : 控制是否显示
            error_iepcrting  :控制显示那些级别的错误  
                php.ini 中，对系统所有运行的PHP程序都有作用
                    display_error = On Off
                    error_iepcrting = E_NOTICE  
                在代码中，值影响当前的网页代码
                    ini_set(‘控制项’，值)
        记录错误日志：
            log_errors: 控制是否记录错误日志
            error_log: 控制错误日志记录到哪里，给定义一个文件名就行
                       一个特殊的值，syslog,则会记录到系统日志中，而不再记录到文件
        自定义错误日志：
            值自己控制错误的显示内容和记录内容
            分两步：
                1 设定自定义错误处理函数 
                    set_error_handler(’函数名‘)
                2 定义该函数（通常需要设定四个参数）
                    function error_handler($errNo,$errMsg,$errFile,$errLine){  $errNo, 错误类型  $errMsg, 错误信息  $errFile, 错误文件    $errLine  错误行号
                        // 这里处理该四个参数，显示写入文件中
                    }        
                注意： 
                    1 该函数无需手工调用，出现错误自动调用
                    2 一旦使用自定义错误， 系统不再负责出错处理
                    3 但如果系统发生严重错误，则不会调用自定义错误函数，显示系统错误
 # 4
    # 函数
        函数的基本使用
            函数定义形式： function fuc(形参1，形参2，。。。){};
            函数调用形式：
                没有返回值 ： fuc（实参1，实参2，。。。）;
                有返回值： $vl = fuc（实参1，实参2，。。。）;

        函数的参数问题
            形参 ： 函数内部可用的局部变量而已
            实参 : 就是一个数据
            默认参数：
                 function fuc(形参 ，形参n1=值1，形参n2=值2，。。。){}
            参数传值：
                默认使用值传递
                可以在参数前加引用符号“&”，就成了引用传递 
            参数length：
                通常一一对应
                有默认值形参，可以省却默认形参，饭只能从右往左省略
            返回值
                默认情况,使用 “值传递”，返回是数据本身，而不是数据的引用
                可以设定为引用返回：
                    function &func(参数1，参数2)){}； //肯定有返回值
                    则调用也得加引用符号 &func(实参);

        函数的其他形式
            1 可变函数： 函数名可以使用变量名来代替
                $f1= 'show';
                $f1(); => show();

            2 匿名函数: 定义函数的时候没有给出名字
                $f=function(){};
                2.2 回调函数
                    function f($fn,行参)


        变量的作用域
            局部
                静态局部
            全局
            超全局

        有关函数的的编程思想       
            递归思想 （递归函数）：
                从大问题出来，逐级找小问题，知道最小问题，再逐级从小到大，返回每级问题
            递推思想 （迭代思想）       
                从最小问题出发，逐级往大方向找出大一级问题的答案，直到最终问题的答案
# 5
    # 数组
        数据遍历：
            基本语法：
                foreach($arr as $key=>$value )  {
                    // 这句是循环体
                    //  $key,$value的值随着遍历的进行，一次次取得数组元素的数据
                    // 此遍历可以 continue 和break；
                }               

        数组指针和遍历原理：
            一个数组内部具有一个指针（并非c语言 的指针），只是一个理念上的
            数组指针也是实现数组遍历的内部机制。
            数组指针操作：
                key() ,current(), next() ,prev(), reset(), end() ,each()
        数组遍历的流程：
            指针初始化》 判断指针位置》有效》取得该元素数据》移动指针到下一个位置》进入循环体。

        for+next+reset 遍历数组：
            $len = count($arr);
            reset($arr); 指针初始化
            for($i=0;$i<$len;$i++){
                $key = key($arr);
                $value = current($arr);
                //do something
                next($arr);
            }
        while+each() +list()遍历数组
            reset($arr); 指针初始化
            while(list($key,$value)=each($arr)){
                //do  something
            }   
        foreach 遍历细节讨论
            1 是标准循环语句，可以中断
            2 正常循环时，值变量使用值传递获取数据
            3 可以对值变量加上引用符号& 来实现引用传值
            4 正常循环时，默认是在原数组上进行遍历，但在遍历过程中试图改变数组（或者改变数组的值，或者增减数组）或对数组进行某种指针操作，则此时 forEach内部会先将该数组拷贝一份，原来数组就会去实现改变，二新拷贝的数组任然进行循环
            5 如果遍历中值变量使用的是引用传值，则如论如何都在原数组上进行操作。

        数组函数    
            指针函数： key() ,current(), next() ,prev(), reset(), end() ,each()
            单元操作函数： array_pop(), array_push(), array_shift(), array_unshift(), array_slice(), array_splice()
            排序函数： sort() , asort() , ksort(),usort(),rsort(),krsort(),shuffle()
            查找函数: in_array(), array_key_exists(),array_search()
            其他函数： count(),array_reverse(),array_merge(),array_sum(),array_map(),array_walk(),range(),array_keys()array_value()

         数组排序思想介绍
            冒泡排序：
                

            选择排序： 

        按值查找： 找到val  返回val
        顺序查找 ： 找到val  返回下标，   找不到返回false;
        二分查找:
            1 针对已经排序的数组（已经排好序了）
            2 是连续的索引数组   ru:0 1 2 3...

            思路：
            第一次循环完，第二次从中间找，第三次再从中间找....不断的缩小范围

# 5
    # 面向对象编程

        -传统的面向过程： 
            将要完成的工作，分作若干个步骤，或再细化为自步骤，然后按步骤从前往后一步一步完成，最终达到目标。
        -现代面向对象
            将要完成的工作，分为"一个一个对象"的任务（功能），每个对象独自完成自己的 任务，任务之间通过“调用” 来实现，最终也完成了整体的工作

            万事万物皆为对象

            面向对象是设计思想的 “升华” ，它是解决大规模的复杂的问题的良好思想。
            面向过程是解决简单问题的思想过程。

        -面向对象基本概念
            类与对象：
                类是用于描述 “某些具有共同特征”的物体的统称。例如：张三是一个对象，李四也是对象，他们都隶属于“人”这个“类”（人类）。同时，我们还隶属于 “脊椎动物类” “哺乳动物类”.....
                    通常一个类所具有共同的特征包括两个方面：
                        外观，形状，描述，数据。。。。。 属性
                        行为，动作，功能。。。。。。。   方法
                对象是一个具体的“物体”，该物体隶属于某个类别（类）
                    通常对象离不开类，没有类就不能有对象

                1 定义类 定义类的语法中，只有3中代码
                    1.1 定义属性  （变量）
                    1.2 定义方法 （函数）
                    1.3 定义常量
                    
                2 创建类的对象：
                    $person1 = new Obj();  //形式一
                    $CName = "Obj";  $person2 = new $CName();  //形式二，  可变类
                    $变量 = new self;  //self 代指类本事，这行代码只能再类内部方法中使用   //形式三
                    $变量 = new 对象名； //形式四 通过对象创建该类的新对象
                    
                    
                3 使用对象
                    1.1 使用属性  $person1->name;
                    1.2 使用方法  $person1-> f1();
                    1.3 使用常量  $person1::PI;
            对象传值：
                对象传值，改变其中一个 另一个也改变
            属性：
                定义形式： 
                    var $v1 ;  定义不赋值
                    var $v1 =2;  定义又赋值
                    public $v1;
                    public $v1 =2 ;     其实var 是public 的一个别名正式用 public 更好
                    错误形式：
                         $v1 = 1+1； //右边不能是表达式
                         $v1 = $v2； //右边不能使变量
                使用形式：
                   $变量->属性名 ；